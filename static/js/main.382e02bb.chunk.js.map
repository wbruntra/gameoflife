{"version":3,"sources":["utils.js","saves.js","App.js","serviceWorker.js","index.js"],"names":["clockAddition","a","b","clockSize","getNeighbors","cellName","gridSize","rowPointer","colPointer","neighborName","split","map","x","Number","row","column","neighbors","Set","i","j","add","determineNextState","liveNeighbors","currentState","flipCell","grid","clonedGrid","has","delete","getNextIteration","newGrid","counter","forEach","hasOwnProperty","makeHashGrid","lifeSeed","Array","keys","Math","random","saves","HO","App","state","ticks","running","tickInterval","mouseClicked","go","timerId","setInterval","iterate","setState","stop","clearInterval","handleCellClick","componentDidMount","cellWidth","window","screen","width","floor","styles","height","clearGrid","renderHashGrid","key","className","style","onMouseOver","onClick","handleSliderChange","e","val","target","value","load","save","JSON","parse","localStorage","getItem","now","Date","timeString","toLocaleDateString","toLocaleTimeString","stringify","from","console","log","this","variant","color","type","min","max","step","onChange","newInterval","React","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.382e02bb.chunk.js","sourcesContent":["import { forEach } from 'lodash'\n\nconst clockAddition = (a, b, clockSize) => {\n  if (a + b < 0) {\n    return a + clockSize + b\n  }\n  if (a + b > clockSize - 1) {\n    return (a + b) % clockSize\n  }\n  return a + b\n}\n\nconst getNeighbors = (cellName, gridSize) => {\n  let [row, column] = cellName.split('-').map((x) => Number(x))\n  let rowPointer, colPointer, neighborName\n  const neighbors = new Set()\n  for (let i = -1; i <= 1; i++) {\n    colPointer = clockAddition(column, i, gridSize)\n    for (let j = -1; j <= 1; j++) {\n      rowPointer = clockAddition(row, j, gridSize)\n      if (colPointer !== column || rowPointer !== row) {\n        neighborName = `${rowPointer}-${colPointer}`\n        neighbors.add(neighborName)\n      }\n    }\n  }\n  return neighbors\n}\n\nconst countLiveNeighbors = (cellName, grid, gridSize) => {\n  const neighbors = getNeighbors(cellName, gridSize)\n  let count = 0\n  neighbors.forEach((neighborName) => {\n    if (grid.has(neighborName)) {\n      count++\n    }\n  })\n  return count\n}\n\nconst determineNextState = (liveNeighbors, currentState) => {\n  if (liveNeighbors === 3) {\n    return true\n  }\n  if (liveNeighbors === 2 && currentState) {\n    return true\n  }\n  return false\n}\n\nconst calculateCellState = (cellName, grid, gridSize) => {\n  const liveNeighbors = countLiveNeighbors(cellName, grid, gridSize)\n  const newState = determineNextState(liveNeighbors, grid.has(cellName))\n  return newState\n}\n\nexport const flipCell = (cellName, grid) => {\n  const clonedGrid = new Set(grid)\n  if (grid.has(cellName)) {\n    clonedGrid.delete(cellName)\n  } else {\n    clonedGrid.add(cellName)\n  }\n  return clonedGrid\n}\n\nexport const getNextIteration = (grid, gridSize) => {\n  const newGrid = new Set()\n  const counter = {}\n  // First pass: propagate all live cells to a counter on their neighbors\n  grid.forEach((cellName) => {\n    const newNeighbors = getNeighbors(cellName, gridSize)\n    newNeighbors.forEach((neighborName) => {\n      if (counter.hasOwnProperty(neighborName)) {\n        counter[neighborName] = counter[neighborName] + 1\n      } else {\n        counter[neighborName] = 1\n      }\n    })\n  })\n  // Second pass: use counter to calculate whether cells from first pass should be alive\n  forEach(counter, (liveNeighbors, cellName) => {\n    const currentState = grid.has(cellName)\n    const newCellState = determineNextState(liveNeighbors, currentState)\n    if (newCellState) {\n      newGrid.add(cellName)\n    }\n  })\n  return newGrid\n}\n\nexport const makeHashGrid = (lifeSeed, gridSize) => {\n  const grid = new Set()\n  ;[...Array(gridSize).keys()].forEach((i) => {\n    return [...Array(gridSize).keys()].forEach((j) => {\n      if (Math.random() > 1 - lifeSeed) {\n        const cellName = `${i}-${j}`\n        grid.add(cellName)\n      }\n    })\n  })\n  return grid\n}\n","const saves = {\n  HO: [\n    '9-9',\n    '10-9',\n    '11-9',\n    '12-9',\n    '13-9',\n    '11-10',\n    '11-11',\n    '9-11',\n    '10-11',\n    '12-11',\n    '13-11',\n    '9-13',\n    '9-14',\n    '9-15',\n    '10-13',\n    '11-13',\n    '12-13',\n    '13-13',\n    '13-14',\n    '13-15',\n    '12-15',\n    '11-15',\n    '10-15',\n  ],\n};\n\nexport default saves;\n","import * as React from 'react'\n// import Button from '@material-ui/core/Button'\nimport './main.scss'\nimport { getNextIteration, makeHashGrid, flipCell } from './utils'\nimport saves from './saves'\n\nclass App extends React.Component {\n  state = {\n    gridSize: 48,\n    lifeSeed: 0.2,\n    grid: new Set(),\n    ticks: 0,\n    running: false,\n    tickInterval: 210,\n    mouseClicked: false,\n  }\n\n  go = () => {\n    const { tickInterval } = this.state\n    this.timerId = setInterval(this.iterate, 570 - tickInterval)\n    this.setState({\n      running: true,\n    })\n  }\n\n  stop = () => {\n    clearInterval(this.timerId)\n    this.setState({\n      running: false,\n    })\n  }\n\n  handleCellClick = (cellName) => {\n    const { grid, running } = this.state\n    if (!running) {\n      const newGrid = flipCell(cellName, grid)\n      this.setState({\n        grid: newGrid,\n      })\n    }\n  }\n\n  componentDidMount = () => {\n    const { gridSize, lifeSeed } = this.state\n    const cellWidth =\n      window.screen.width > 600\n        ? Math.floor(600 / gridSize) - 2\n        : Math.floor(window.screen.width / gridSize) - 2\n    this.styles = {\n      width: cellWidth,\n      height: cellWidth,\n    }\n    this.setState({\n      grid: makeHashGrid(lifeSeed, gridSize),\n    })\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerId)\n  }\n\n  iterate = () => {\n    const updater = (state) => {\n      const { grid, gridSize, ticks } = state\n      const nextGrid = getNextIteration(grid, gridSize)\n      return {\n        grid: nextGrid,\n        ticks: ticks + 1,\n      }\n    }\n    this.setState(updater)\n  }\n\n  clearGrid = () => {\n    const grid = new Set()\n    this.setState({\n      grid,\n      ticks: 0,\n    })\n  }\n\n  renderHashGrid = () => {\n    const { gridSize, grid } = this.state\n    return (\n      <table>\n        <tbody>\n          {[...Array(gridSize).keys()].map((i) => {\n            return (\n              <tr key={`row-${i}`} className=\"grid-row\">\n                {[...Array(gridSize).keys()].map((j) => {\n                  const cellName = `${i}-${j}`\n                  return (\n                    <td\n                      style={this.styles}\n                      onMouseOver={() => {\n                        if (this.state.mouseClicked) {\n                          this.handleCellClick(cellName)\n                        }\n                      }}\n                      onClick={() => {\n                        this.handleCellClick(cellName)\n                      }}\n                      key={`cell-${cellName}`}\n                      className={grid.has(cellName) ? 'black cell' : 'cell'}\n                    />\n                  )\n                })}\n              </tr>\n            )\n          })}\n        </tbody>\n      </table>\n    )\n  }\n\n  handleSliderChange = (e) => {\n    const { running, gridSize } = this.state\n    if (running) {\n      return\n    }\n    const val = Number(e.target.value) / 100\n    this.setState({\n      lifeSeed: val,\n      grid: makeHashGrid(val, gridSize),\n      ticks: 0,\n    })\n  }\n\n  load = (key) => {\n    const grid = new Set(saves[key])\n    this.setState({\n      grid,\n    })\n  }\n\n  save = () => {\n    const { grid } = this.state\n    const saves = JSON.parse(localStorage.getItem('saves') || '{}')\n    const now = new Date()\n    const timeString = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}`\n    const gridString = JSON.stringify(Array.from(grid))\n    saves[timeString] = grid\n    console.log(saves)\n  }\n\n  render() {\n    const { grid, gridSize, lifeSeed, ticks, running, tickInterval } = this.state\n    return (\n      <div\n        className=\"container\"\n        // onPointerDown={() => {\n        //   this.setState({ mouseClicked: true });\n        // }}\n        // onPointerUp={() => {\n        //   this.setState({ mouseClicked: false });\n        // }}\n      >\n        <p>Ticks: {ticks}</p>\n        {this.renderHashGrid(grid)}\n        <div className=\"row\">\n          <div className=\"section\">\n            {!running && (\n              <button\n                variant=\"contained\"\n                color=\"primary\"\n                onClick={() => {\n                  this.clearGrid()\n                }}\n              >\n                Clear Grid\n              </button>\n            )}{' '}\n            {!running && (\n              <button\n                variant=\"contained\"\n                color=\"primary\"\n                onClick={() => {\n                  this.setState({\n                    grid: makeHashGrid(lifeSeed, gridSize),\n                    ticks: 0,\n                  })\n                }}\n              >\n                Random Grid\n              </button>\n            )}{' '}\n            {!running && (\n              <button\n                variant=\"contained\"\n                color=\"primary\"\n                onClick={() => {\n                  this.iterate()\n                }}\n              >\n                Step\n              </button>\n            )}{' '}\n            <button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => {\n                if (!running) {\n                  this.go()\n                } else {\n                  this.stop()\n                }\n              }}\n            >\n              {!running ? 'GO!' : 'STOP!'}\n            </button>\n            {/* <button color=\"primary\" onClick={this.save}>\n              Save\n            </button> */}\n            {!running && (\n              <button\n                color=\"primary\"\n                onClick={() => {\n                  this.load('HO')\n                }}\n              >\n                CLICK HERE!\n              </button>\n            )}\n          </div>\n        </div>\n        <div className=\"row\">\n          {/* <Slider\n              style={{width: '400px'}}\n              value={100 - lifeSeed * 100}\n              aria-labelledby=\"label\"\n              onChange={this.handleSliderChange}\n            /> */}\n          {!running ? (\n            <input\n              type=\"range\"\n              min=\"1\"\n              max=\"50\"\n              value={lifeSeed * 100}\n              className=\"slider\"\n              onChange={this.handleSliderChange}\n            />\n          ) : (\n            <div>\n              <label>Slower/Faster</label>\n              <input\n                type=\"range\"\n                min=\"3\"\n                max=\"51\"\n                step=\"6\"\n                value={tickInterval / 10}\n                onChange={(e) => {\n                  const newInterval = Number(e.target.value) * 10\n                  clearInterval(this.timerId)\n                  this.timerId = setInterval(this.iterate, 570 - newInterval)\n                  this.setState({\n                    tickInterval: newInterval,\n                  })\n                }}\n              />\n            </div>\n          )}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}