{"version":3,"sources":["utils.js","saves.js","App.js","serviceWorker.js","index.js"],"names":["clockAddition","a","b","clockSize","getNeighbors","cellName","grid","gridSize","rowPointer","colPointer","neighborName","wrap","JSON","parse","row","column","neighbors","Set","i","j","stringify","add","countLiveNeighbors","cellNeighbors","count","forEach","has","determineNextCellState","liveNeighbors","currentCellState","flipCell","clonedGrid","delete","getNextIteration","limitSize","newGrid","cellsToEvaluate","Math","abs","currentState","liveNeighborCount","makeHashGrid","lifeSeed","Array","keys","random","saves","HO","App","state","ticks","running","tickInterval","mouseClicked","setGridSize","size","Number","setState","styles","adjustTableStyles","go","timerId","setInterval","iterate","prevState","stop","clearInterval","handleCellClick","cellWidth","window","screen","width","floor","height","componentDidMount","clearGrid","renderHashGrid","map","key","className","style","onMouseOver","onClick","handleSliderChange","e","val","target","value","load","savedArray","localStorage","getItem","save","now","Date","timeString","toLocaleDateString","toLocaleTimeString","gridString","from","savesString","console","log","setItem","this","liveCells","htmlFor","type","id","min","max","step","onChange","newInterval","checked","explanation","React","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.91683eac.chunk.js","sourcesContent":["import { forEach } from 'lodash'\n\n/**\n * Add a + b where range of result is between 0 and clockSize\n */\nconst clockAddition = (a, b, clockSize) => {\n  if (a + b < 0) {\n    return a + clockSize + b\n  }\n  if (a + b > clockSize - 1) {\n    return (a + b) % clockSize\n  }\n  return a + b\n}\n\n/**\n * Get Set of neighbors for cellName\n */\nconst getNeighbors = (cellName, grid, gridSize, wrap = true) => {\n  let liveNeighborCount = 0\n  let [row, column] = JSON.parse(cellName)\n  let rowPointer, colPointer, neighborName\n  const neighbors = new Set()\n  for (let i = -1; i <= 1; i++) {\n    if (wrap) {\n      colPointer = clockAddition(column, i, gridSize)\n    } else {\n      colPointer = column + i\n    }\n    for (let j = -1; j <= 1; j++) {\n      if (wrap) {\n        rowPointer = clockAddition(row, j, gridSize)\n      } else {\n        rowPointer = row + j\n      }\n      // neighborName = `${rowPointer}-${colPointer}`\n      neighborName = JSON.stringify([rowPointer, colPointer])\n      if (neighborName !== cellName) {\n        // if (grid.has(neighborName)) {\n        //   liveNeighborCount++\n        // }\n        neighbors.add(neighborName)\n      }\n    }\n  }\n  return neighbors\n}\n\nconst countLiveNeighbors = (cellName, grid, gridSize, wrap = true) => {\n  const cellNeighbors = getNeighbors(cellName, grid, gridSize, wrap)\n  let count = 0\n  cellNeighbors.forEach((neighborName) => {\n    if (grid.has(neighborName)) {\n      count++\n    }\n  })\n  return count\n}\n\nconst getLiveNeighborCount = (cellName, grid) => {}\n\nconst determineNextCellState = (liveNeighbors, currentCellState) => {\n  if (liveNeighbors === 3) {\n    return true\n  }\n  if (liveNeighbors === 2 && currentCellState) {\n    return true\n  }\n  return false\n}\n\nconst calculateCellState = (cellName, grid, gridSize) => {\n  const liveNeighbors = countLiveNeighbors(cellName, grid, gridSize)\n  const newState = determineNextCellState(liveNeighbors, grid.has(cellName))\n  return newState\n}\n\nexport const flipCell = (cellName, grid) => {\n  const clonedGrid = new Set(grid)\n  if (grid.has(cellName)) {\n    clonedGrid.delete(cellName)\n  } else {\n    clonedGrid.add(cellName)\n  }\n  return clonedGrid\n}\n\nexport const getNextIteration = (grid, gridSize, wrap = true, limitSize = false) => {\n  const newGrid = new Set()\n  // First pass: Collect all live cells and their neighbors for evaluation\n  const cellsToEvaluate = new Set()\n  grid.forEach((cellName) => {\n    cellsToEvaluate.add(cellName)\n    const cellNeighbors = getNeighbors(cellName, grid, gridSize, wrap)\n    cellNeighbors.forEach((neighborName) => {\n      cellsToEvaluate.add(neighborName)\n    })\n  })\n  // Second pass: Evaluate cells\n  cellsToEvaluate.forEach((cellName) => {\n    let [row, column] = JSON.parse(cellName)\n    if (limitSize && (Math.abs(row) > 150 || Math.abs(column) > 150)) {\n      return\n    }\n    const currentState = grid.has(cellName)\n    const liveNeighborCount = countLiveNeighbors(cellName, grid, gridSize, wrap)\n    const newCellState = determineNextCellState(liveNeighborCount, currentState)\n    if (newCellState) {\n      newGrid.add(cellName)\n    }\n  })\n  return newGrid\n}\n\nexport const makeHashGrid = (lifeSeed, gridSize) => {\n  const grid = new Set()\n  ;[...Array(gridSize).keys()].forEach((i) => {\n    return [...Array(gridSize).keys()].forEach((j) => {\n      if (Math.random() > 1 - lifeSeed) {\n        const cellName = JSON.stringify([i, j])\n        grid.add(cellName)\n      }\n    })\n  })\n  return grid\n}\n","const saves = {\n  HO: JSON.stringify([\n    \"[9,9]\",\n    \"[10,9]\",\n    \"[11,9]\",\n    \"[12,9]\",\n    \"[13,9]\",\n    \"[11,10]\",\n    \"[11,11]\",\n    \"[9,11]\",\n    \"[10,11]\",\n    \"[12,11]\",\n    \"[13,11]\",\n    \"[9,13]\",\n    \"[9,14]\",\n    \"[9,15]\",\n    \"[10,13]\",\n    \"[11,13]\",\n    \"[12,13]\",\n    \"[13,13]\",\n    \"[13,14]\",\n    \"[13,15]\",\n    \"[12,15]\",\n    \"[11,15]\",\n    \"[10,15]\",\n  ]),\n}\n\nexport default saves\n","import * as React from 'react'\nimport './styles/main.scss'\nimport { getNextIteration, makeHashGrid, flipCell } from './utils'\nimport saves from './saves'\n\nclass App extends React.Component {\n  state = {\n    gridSize: 32,\n    lifeSeed: 0.2,\n    grid: new Set(),\n    ticks: 0,\n    running: false,\n    tickInterval: 210,\n    mouseClicked: false,\n    wrap: false,\n  }\n\n  setGridSize = (size) => {\n    const gridSize = Number(size)\n    this.setState({\n      gridSize,\n    })\n    this.styles = this.adjustTableStyles(gridSize)\n  }\n\n  go = () => {\n    const { tickInterval } = this.state\n    this.timerId = setInterval(this.iterate, 570 - tickInterval)\n    this.setState((prevState) => ({\n      running: !prevState.running,\n    }))\n  }\n\n  stop = () => {\n    clearInterval(this.timerId)\n    this.setState((prevState) => ({\n      running: !prevState.running,\n    }))\n  }\n\n  handleCellClick = (cellName) => {\n    const { grid, running } = this.state\n    if (!running) {\n      const newGrid = flipCell(cellName, grid)\n      this.setState({\n        grid: newGrid,\n      })\n    }\n  }\n\n  adjustTableStyles = (gridSize) => {\n    const cellWidth =\n      window.screen.width > 600\n        ? Math.floor(600 / gridSize) - 2\n        : Math.floor(window.screen.width / gridSize) - 2\n    return {\n      width: cellWidth,\n      height: cellWidth,\n    }\n  }\n\n  componentDidMount = () => {\n    const { gridSize, lifeSeed } = this.state\n    this.styles = this.adjustTableStyles(gridSize)\n    this.setState({\n      grid: makeHashGrid(lifeSeed, gridSize),\n    })\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerId)\n  }\n\n  iterate = () => {\n    const updater = (state) => {\n      const { grid, gridSize, ticks, wrap } = state\n      const nextGrid = getNextIteration(grid, gridSize, wrap, true)\n      return {\n        grid: nextGrid,\n        ticks: ticks + 1,\n      }\n    }\n    this.setState(updater)\n  }\n\n  clearGrid = () => {\n    const grid = new Set()\n    this.setState({\n      grid,\n      ticks: 0,\n    })\n  }\n\n  renderHashGrid = () => {\n    const { gridSize, grid } = this.state\n    return (\n      <table>\n        <tbody>\n          {[...Array(gridSize).keys()].map((i) => {\n            return (\n              <tr key={`row-${i}`} className=\"grid-row\">\n                {[...Array(gridSize).keys()].map((j) => {\n                  const cellName = JSON.stringify([i, j])\n                  return (\n                    <td\n                      style={this.styles}\n                      onMouseOver={() => {\n                        if (this.state.mouseClicked) {\n                          this.handleCellClick(cellName)\n                        }\n                      }}\n                      onClick={() => {\n                        this.handleCellClick(cellName)\n                      }}\n                      key={`cell-${cellName}`}\n                      className={`${grid.has(cellName) ? '' : ''}  cell`}\n                    >\n                      <div className={grid.has(cellName) ? 'live' : ''} >\n                      </div>\n                    </td>\n                  )\n                })}\n              </tr>\n            )\n          })}\n        </tbody>\n      </table>\n    )\n  }\n\n  handleSliderChange = (e) => {\n    const { running, gridSize } = this.state\n    if (running) {\n      return\n    }\n    const val = Number(e.target.value) / 100\n    this.setState({\n      lifeSeed: val,\n      grid: makeHashGrid(val, gridSize),\n      ticks: 0,\n    })\n  }\n\n  load = (key) => {\n    let savedArray\n    if (key === 'default') {\n      savedArray = JSON.parse(localStorage.getItem('save') || '[]')\n    } else {\n      savedArray = JSON.parse(saves[key])\n    }\n    const grid = new Set(savedArray)\n    this.setState({\n      grid,\n    })\n  }\n\n  save = () => {\n    const { grid } = this.state\n    const save = JSON.parse(localStorage.getItem('save') || '[]')\n    const saves = JSON.parse(localStorage.getItem('saves') || '{}')\n    const now = new Date()\n    const timeString = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}`\n    const gridString = JSON.stringify(Array.from(grid))\n    saves[timeString] = [...grid]\n    const savesString = JSON.stringify(saves)\n    console.log(savesString)\n    localStorage.setItem('save', gridString)\n    // localStorage.setItem('saves', saves)\n  }\n\n  render() {\n    const { grid, gridSize, lifeSeed, ticks, running, tickInterval } = this.state\n    const liveCells = grid.size\n    return (\n      <div className=\"container\">\n        <h1>Conway's Game of Life</h1>\n        <div className=\"row\">\n          <div className=\"col\">\n            <p>Iterations: {ticks}</p>\n          </div>\n          <div className=\"col\">\n            <p>Live cells: {liveCells}</p>\n          </div>\n        </div>\n        <div className=\"row mb-3\">\n          <div className=\"col-md-2 mb-3 mb-md-0\">\n            <button\n              className=\"btn btn-primary\"\n              onClick={() => {\n                if (!running) {\n                  this.go()\n                } else {\n                  this.stop()\n                }\n              }}\n            >\n              {!running ? 'GO!' : 'STOP!'}\n            </button>\n            {!running && (\n              <button\n                className=\"btn btn-primary\"\n                onClick={() => {\n                  this.clearGrid()\n                }}\n              >\n                Clear Grid\n              </button>\n            )}{' '}\n            {!running && (\n              <button\n                className=\"btn btn-primary\"\n                onClick={() => {\n                  this.setState({\n                    grid: makeHashGrid(lifeSeed, gridSize),\n                    ticks: 0,\n                  })\n                }}\n              >\n                Random\n              </button>\n            )}{' '}\n            {!running && (\n              <button\n                className=\"btn btn-primary\"\n                onClick={() => {\n                  this.iterate()\n                }}\n              >\n                Step\n              </button>\n            )}{' '}\n            {!running && (\n              <>\n                <button className=\"btn btn-primary\" onClick={this.save}>\n                  Save\n                </button>\n                <button className=\"btn btn-primary\" onClick={() => this.load('default')}>\n                  Load\n                </button>\n              </>\n            )}\n            {!running && (\n              <button\n                className=\"btn btn-primary\"\n                onClick={() => {\n                  this.load('HO')\n                }}\n              >\n                Preset\n              </button>\n            )}\n          </div>\n\n          <div className=\"col-md-9\">{this.renderHashGrid(grid)}</div>\n        </div>\n        <div className=\"row\">\n          <div className=\"col-8\">\n            {!running ? (\n              <div>\n                <div className=\"form-check\">\n                  <input\n                    onChange={() => {\n                      this.setState((prevState) => ({ wrap: !prevState.wrap }))\n                    }}\n                    className=\"form-check-input\"\n                    checked={this.state.wrap}\n                    type=\"checkbox\"\n                    id=\"defaultCheck1\"\n                  />\n\n                  <label className=\"form-check-label\" htmlFor=\"defaultCheck1\">\n                    Round world?\n                  </label>\n                </div>\n\n                <div>\n                  <label className=\"mr-3\" htmlFor=\"densityRange\">\n                    Initial Density\n                  </label>\n                  <input\n                    type=\"range\"\n                    min=\"1\"\n                    max=\"50\"\n                    value={lifeSeed * 100}\n                    className=\"custom-range\"\n                    onChange={this.handleSliderChange}\n                    id=\"densityRange\"\n                  />\n                </div>\n                <div>\n                  <label className=\"mr-3\" htmlFor=\"grid-size\">\n                    Grid Size\n                  </label>\n                  <input\n                    id=\"grid-size\"\n                    type=\"number\"\n                    min=\"10\"\n                    max=\"50\"\n                    value={this.state.gridSize}\n                    onChange={(e) => {\n                      this.setGridSize(e.target.value)\n                    }}\n                  />\n                </div>\n              </div>\n            ) : (\n              <div>\n                <label className=\"mr-3\" htmlFor=\"customRange1\">\n                  Slower/Faster\n                </label>\n                <input\n                  type=\"range\"\n                  className=\"custom-range\"\n                  id=\"customRange1\"\n                  min=\"3\"\n                  max=\"51\"\n                  step=\"6\"\n                  value={tickInterval / 10}\n                  onChange={(e) => {\n                    const newInterval = Number(e.target.value) * 10\n                    clearInterval(this.timerId)\n                    this.timerId = setInterval(this.iterate, 570 - newInterval)\n                    this.setState({\n                      tickInterval: newInterval,\n                    })\n                  }}\n                ></input>\n              </div>\n            )}\n          </div>\n        </div>\n        <hr />\n        <div className=\"row\">\n          <div className={`explanation ${this.state.explanation} ? 'show' : ''`}>\n            <ul>\n              <li>Each cell has 8 neighboring cells</li>\n              <li>A live cell with 2 or 3 live neighbors will continue to the next iteration</li>\n              <li>A dead cell with exactly 3 live neighbors will come to life</li>\n              <li>A live cell with 4 or more live neighbors will die, as if by overpopulation</li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}